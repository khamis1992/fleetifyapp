// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { getSupabaseConfig, debugLog, securityLog } from '@/lib/env';
import { createCapacitorStorageAdapter } from '@/lib/capacitorStorage';

// Get Supabase configuration securely
let supabaseConfig: ReturnType<typeof getSupabaseConfig>;

try {
  supabaseConfig = getSupabaseConfig();
  debugLog('Supabase config loaded successfully', {
    hasUrl: !!supabaseConfig.url,
    hasKey: !!supabaseConfig.anonKey
  });
} catch (error) {
  console.error('‚ùå [SUPABASE] Failed to load Supabase configuration:', error);
  throw error;
}

// Validate configuration
if (!supabaseConfig.url || !supabaseConfig.anonKey) {
  const error = 'Missing required Supabase configuration';
  securityLog(error, {
    hasUrl: !!supabaseConfig.url,
    hasKey: !!supabaseConfig.anonKey
  });
  throw new Error(error);
}

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(supabaseConfig.url, supabaseConfig.anonKey, {
  auth: {
    storage: createCapacitorStorageAdapter(),
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true,
    flowType: 'pkce',
    // Use standard stable storage key so sessions persist across page refreshes
    storageKey: `sb-${supabaseConfig.url.split('//')[1].split('.')[0]}-auth-token`,
  },
  // Add retry logic for better reliability
  global: {
    headers: { 'x-client-info': 'fleetify-web' },
    fetch: async (url, options, retries = 1, delay = 500) => {
      // Add timeout to prevent hanging requests with retry logic
      for (let attempt = 0; attempt <= retries; attempt++) {
        try {
          // Reduced timeout for faster failure detection
          const timeoutMs = 10000; // 10s timeout (reduced from 25s)
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
          
          const response = await fetch(url, {
            ...options,
            signal: controller.signal,
          });
          
          clearTimeout(timeoutId);

          // Return response if successful or if this is the last attempt
          if (response.ok || attempt === retries) {
            return response;
          }
          
          // If not successful and not last attempt, retry
          throw new Error(`HTTP ${response.status}`);
        } catch (error: any) {
          // Log timeout warnings only in dev mode
          if (import.meta.env.DEV && error?.name === 'AbortError') {
            console.warn(`[SUPABASE] Attempt ${attempt + 1}: Request timed out after 10s:`, url);
          }
          
          // If this is the last attempt, throw the error
          if (attempt === retries) {
            if (import.meta.env.DEV) {
              console.error(`[SUPABASE] All ${retries + 1} attempts failed for:`, url);
            }
            throw error;
          }
          
          // Wait before retrying
          await new Promise(resolve => setTimeout(resolve, delay));
          delay *= 1.5; // Moderate exponential backoff
        }
      }
      
      // This should never be reached, but TypeScript needs it
      throw new Error('Unexpected fetch error');
    },
  },
  // Realtime configuration for better performance
  realtime: {
    params: {
      eventsPerSecond: 10,
    },
  },
});

// Clean up orphaned per-tab auth keys from previous implementation that used Date.now()
try {
  const projectRef = supabaseConfig.url.split('//')[1].split('.')[0];
  const orphanedKeyPattern = new RegExp(`^sb-${projectRef}-auth-token-\\d+$`);
  Object.keys(localStorage)
    .filter(key => orphanedKeyPattern.test(key))
    .forEach(key => localStorage.removeItem(key));
} catch (e) {
  // Ignore cleanup errors
}

// Export configuration for secure access if needed
export { supabaseConfig };